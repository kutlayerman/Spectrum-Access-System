#    Copyright 2018 SAS Project Authors. All Rights Reserved.
#
#    Licensed under the Apache License, Version 2.0 (the "License");
#    you may not use this file except in compliance with the License.
#    You may obtain a copy of the License at
#
#        http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS,
#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#    See the License for the specific language governing permissions and
#    limitations under the License.

"""A fake implementation of database server."""

import json
import logging
import os
import shutil
import threading
from urlparse import urlparse
from datetime import datetime
from BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler


class FakeDatabaseTestHarness(threading.Thread):
  """Implements a fake database server by creating a HTTP server.

  Test Harness acting as a HTTP Server to receive Pull/GET requests from SAS UUT.
  """

  def __init__(self, host_name, port=80):
    """This constructor initializes the FakeDatabaseTestHarness class with
    required information passed as args.

    Args:
      host_name: Host name of Fake Database Test Harness that the SAS UUT
                 should connect to for FDB records.
      port: Port of Fake Database Test Harness host where http server
            is configured.
    """

    super(FakeDatabaseTestHarness, self).__init__()

    self.host_name = host_name
    self.port = port
    self.db_url = "http://" + host_name + ':' + str(port) + '/' + 'db_sync'
    self.db_file_path = os.path.join(self.__generateTempDirectory(), 'records_db.json')
    self.setDaemon(True)

    self.server = FakeDatabaseHttpServer(urlparse(self.db_url).path,
                                         self.db_file_path,
                                         (self.host_name, self.port),
                                         FakeDatabaseTestHarnessHandler)

  def __del__(self):
    self.cleanDumpFile()

  def __generateTempDirectory(self):
    """This method will generate a random directory using the current timestamp.

    The relative path of the directory is ./fake_database/YYYY-MM-DD-HH-MM-SS-mmmmmm.

    Returns: Returns the absolute path of the created temporary directory.
    """

    current_time_stamp = datetime.now().strftime('%Y-%m-%d_%H-%M-%S-%f')
    temp_dump_dir_path = os.path.join('fake_database', current_time_stamp)
    os.makedirs(temp_dump_dir_path)

    return temp_dump_dir_path

  def getBaseUrl(self):
    return self.db_url

  def run(self):
    """Starts the HTTP Server as background thread.

    The run() method is an overridden method from thread class and it gets
    invoked when the thread is started using thread.start().
    """

   # Start HTTP server
    self.server.serve_forever()
    logging.info("Started Fake Database Server")

  def shutdown(self):
    """This method is used to stop HTTPServer.

    The shutdown() method is an overridden method from HTTPServer class and
    it stops the serve_forever() loop.
    """

    # Shut down HTTP Server
    self.server.shutdown()
    logging.info("Stopped Fake Database Harness Server")

  def cleanDumpFile(self):
    """Clean existing dumpfile if any."""

    # The split() method returns a list of words in the \
    # string based on the separator ('/').
    # The join() method returns a string in which string \
    # elements are joined by a separator ('/').

    # Remove the directory used for this DB server. Note that the parent directory
    # ./fake_database is not removed as other instances could be using it.
    shutil.rmtree('/'.join((self.db_file_path.split('/')[:-1])))

    logging.info('Temporary directory generated by this testcase is cleaned successfully')

  def writeDatabaseFile(self, data):
    """Write JSON data to database file."""

    with open(self.db_file_path, 'w') as file_handler:
      file_handler.writelines(json.dumps(data, sort_keys=True, indent=4))


class FakeDatabaseHttpServer(HTTPServer):
  """The class FakeDatabaseHttpServer overrides built-in HTTPServer and takes the 
     takes the parameter db_url_path used to serve the file(s)
  """

  def __init__(self, db_url_path, db_file_path, server_address, RequestHandlerClass):
    self.db_url_path = db_url_path
    self.db_file_path = db_file_path
    HTTPServer.__init__(self, server_address, RequestHandlerClass)


class FakeDatabaseTestHarnessHandler(BaseHTTPRequestHandler):
  """FakeDatabaseTestHarnessHandler class is inherited with
     BaseHTTPRequestHandler to serve HTTP Response.
  """

  def do_GET(self):
    """Handles PULL/GET requests"""

    parsed_path = urlparse(self.path)
    # If the GET request path does not match the Database URL path then respond
    # with 404 response.
    if parsed_path.path != self.server.db_url_path:
      self.log_message('Requested url :{0} does not match with Database Server URL '
                       'path:{1}'.format(parsed_path.path, self.server.db_url_path))
      self.send_response(404)
      return

    # Load the records_db.json and write content in HTTP response stream with
    # 200 OK response.
    # If any exception occurs while reading, handle error and respond
    # with 404 'Not Found'.
    try:
      file_data = json.load(open(self.server.db_file_path))
    except IOError:
      self.log_message('There is an error reading file:{}'.format(
          self.server.db_file_path))
      self.send_response(404)
      return
    else:
      self.send_response(200)
      self.send_header('Content-type', 'application/json')
      self.end_headers()
      self.wfile.write(file_data)
      return
